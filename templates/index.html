<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Music Player</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
      /* Default light theme */
      background-color: #fff;
      color: #000;
    }

    audio {
      width: 100%;
      max-width: 600px;
    }

    #metadata,
    #skip-button {
      margin-top: 20px;
    }

    /* Dark theme styles */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #333;
        color: #fff;
      }

      a {
        color: #4a90e2;
        /* A lighter blue for better visibility on dark backgrounds */
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>
  <script>
    var audioctx = {
      current_track: -1,
      current_chunk: -1,
      max_chunks: -1
    }
    var buffers = {};
    var sources = {};

    function clearAudioContext() {
      audioctx.current_track = -1;
      audioctx.current_chunk = -1;
      audioctx.max_chunks = -1;
    }

    document.addEventListener('DOMContentLoaded', function () {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      console.log('Audio context created');

      // accBufferTime is the accumulated buffer time of all the scheduled chunks

      function initAudioContext() {
        if (audioctx.current_track >= 0) {
          return;
        }

        const response = $.get('/get', audioctx, function (data) {
          audioctx.current_track = data.current_track;
          audioctx.current_chunk = data.current_chunk;
          audioctx.max_chunks = data.max_chunks;
          playAudio();
        });
      }

      async function loadChunk(chunk_number, accBufferTime, chunk0LoadTime, baseTime) {
        if (chunk_number >= audioctx.max_chunks) {
          return [null, null];
        }
        if (buffers[chunk_number]) {
          return [buffers[chunk_number], chunk_number];
        }

        const response = await fetch('/play?current_track=' + audioctx.current_track + '&current_chunk=' + chunk_number);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        buffers[chunk_number] = audioBuffer;
        return [audioBuffer, chunk_number, accBufferTime, chunk0LoadTime, baseTime];
      }

      function scheduleNextChunk(chunkBuffer) {
        let [audioBuffer, chunk_number, accBufferTime, chunk0LoadTime, baseTime] = chunkBuffer;
        if (!audioBuffer) {
          setTimeout(function () {
            clearAudioContext();
            playAudio(audioContext.currentTime + 1);
          }, (accBufferTime - audioContext.currentTime + baseTime) * 1000);
          return;
        }
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        // Schedule the audio slightly differnetly if the chunk is the first chunk
        // If baseTime > now, then we are scheduling chunk 0 to play in the future
        // Then chunk0LoadTime should be baseTime + 0
        // Otherwise if basetime is in the past, then we are scheduling chunk 0 to play now
        if (chunk0LoadTime === -1) {
          chunk0LoadTime = Math.max(audioContext.currentTime - baseTime, 0);
          source.start(baseTime);
        }
        else {
          source.start(accBufferTime + chunk0LoadTime + baseTime);
        }
        sources[chunk_number] = source;
        source.onended = function () {
          source.disconnect();
          delete sources[chunk_number];
        };
        loadChunk(
          chunk_number + 1,
          accBufferTime + audioBuffer.duration,
          chunk0LoadTime,
          baseTime).then(scheduleNextChunk);
      }

      // BaseTime in seconds is the time when the first chunk should be played
      // Relative to the creation of the audio context
      // If baseTime is in the past, then the first chunk should be played immediately
      function playAudio(baseTime) {
        if (audioctx.current_track === -1 || audioctx.current_chunk === -1 || audioctx.max_chunks === -1) {
          initAudioContext();
          return;
        }

        loadChunk(0, 0, -1, baseTime).then(scheduleNextChunk);
      }

      playAudio();
    });
  </script>
</head>

<body>
  <h1>Streaming Audio Player</h1>
  <p>Audio is being streamed and played...</p>
</body>

</html>
